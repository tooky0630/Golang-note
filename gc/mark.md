# GC
1. V1.3之前
1.3及之前是按标记-清除算法，流程如：启动STW-Mark标记-Sweep清除-停止STW
缺点：STW过长，程序停顿。产生碎片
2. V1.3
V1.3缩短了STW时间，只在Mark标记阶段STW
3. 三色标记法 V1.5
将所有对象分为白色、灰色、黑色；
一开始，所有对象为白色；
从所有Root Set出发(堆、栈)，遍历所有引用的对象，标记为灰色；
遍历所有灰色对象的引用，将其标记为灰色，本身标记为黑色；
不断循环，最后白色的对象则为不可达对象，清除。
缺点：
仍需要STW，如果不STW，标记过程中，黑色对象修改引用一个白色对象，那该引用会被删除
4. 引入屏障机制 
“强-弱”三色不定式
强：不存在黑色对象引用到白色对象的指针
弱：所有被黑色对象引用的白色对象都处于灰色保护状态
插入屏障：
在A对象引用B对象的时候，B对象被标记为灰色。满足：强三色不定式（黑色对象不会引用到白色对象）
在栈空间不会使用，因为栈空间需要响应速度快，函数调用弹出频繁。所有全部扫描之后，需要重新对栈进行扫描，为了对象不丢失，此次会STW
删除屏障：
在删除对一个对象的引用时，如果该对象为灰色或白色，将被删除对象标记为灰色。（保证灰色到白色的路径不会断）
缺点：
插入写屏障：结束时需要STW重新扫描栈区，标记栈上引用对象的存活情况
删除写屏障：回收精度低，GC开始时要STW扫描栈区保留初始快照，这个过程会保护开始时刻的所有存活对象

5. 混合写屏障 V1.8
GC开始的时候，扫描栈区，将可达对象全部标记为黑。堆区使用“4.屏障机制”
ex：
1.堆对象删除引用，删除的引用变成栈对象的下游
堆对象删除引用，触发堆区写屏障，引用变成灰色，挂到栈对象下，可以保护后续的路径
2.对象被栈对象删除引用，挂到另一个栈对象下
因为栈对象都是黑色，栈区不触发写屏障，直接删除引用，且都是黑色，对象被保护
3.对象被一个堆对象删除引用，挂到另一个堆对象下游
堆对象删除引用，被删除对象变成灰色。可以保护对象

栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。
